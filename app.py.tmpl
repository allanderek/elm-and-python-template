from fastapi import FastAPI, Request, HTTPException, Depends, Response, status
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
import argon2
import os
import jwt
import contextlib
import datetime
import hashlib
import binascii
import re
import json
import sys
from functools import wraps
import sqlite3
import inspect
import base64
import hmac
from typing import Optional, Dict, Any
import uvicorn

# Global variables that will be set by create_app
app = FastAPI()
config = {
  "prettyLogging": True,
  "logLevel": -1,
  "jwtSecret": "34edf35d-4b7b-4b7b-8b7b-4b7b4b7b4b7b",
  "dbFilepath": "debug.db",
  "port": 3003,
  "debug": True
  }
password_hasher = argon2.PasswordHasher()

# Make sure the static directory exists
os.makedirs('./static', exist_ok=True)

AUTH_COOKIE_NAME = "auth_token"
AUTH_COOKIE_MAX_DAYS = 360
AUTH_COOKIE_MAX_AGE = AUTH_COOKIE_MAX_DAYS * 24 * 60 * 60  # 360 days in seconds

# Pydantic models for request/response bodies
class LoginRequest(BaseModel):
    username: str
    password: str

class RegisterRequest(BaseModel):
    username: str
    password: str
    email: str
    fullname: Optional[str] = None

class ProfileUpdateRequest(BaseModel):
    fullname: str

class UserResponse(BaseModel):
    id: int
    username: str
    fullname: Optional[str]
    email: str
    admin: bool

class AuthResponse(BaseModel):
    success: bool
    message: str
    user: Optional[UserResponse] = None

class ErrorResponse(BaseModel):
    error: str



@contextlib.contextmanager
def db_transaction():
    """Context manager for SQLite database transactions."""
    db = sqlite3.connect(config['dbFilepath'])
    db.row_factory = sqlite3.Row  # Enable dictionary-like access

    try:
        yield db
        db.commit()
    except sqlite3.IntegrityError as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Database integrity error: {str(e)}")
    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        db.close()

def get_user_id_from_cookie(request: Request) -> Optional[int]:
    """Extract user_id from cookie"""
    token = request.cookies.get(AUTH_COOKIE_NAME)
    if not token:
        return None

    try:
        payload = jwt.decode(token, config["jwtSecret"], algorithms=[config["jwtAlgorithm"]])
        return payload.get('user_id')
    except jwt.PyJWTError:
        return None

def get_current_user_id(request: Request) -> int:
    """FastAPI dependency for authentication"""
    user_id = get_user_id_from_cookie(request)
    if not user_id:
        raise HTTPException(status_code=401, detail="Authentication required")
    return user_id

def require_admin_user(request: Request) -> int:
    """FastAPI dependency for admin authentication"""
    user_id = get_user_id_from_cookie(request)
    if not user_id:
        raise HTTPException(status_code=401, detail="Authentication required")

    with db_transaction() as db:
        query = "SELECT admin FROM users WHERE id = ?"
        result = db.execute(query, (user_id,)).fetchone()

        if not result or result['admin'] != 1:
            raise HTTPException(status_code=403, detail="Admin privileges required")

    return user_id

def verify_password(stored_password, provided_password):
    """Verify password using argon2"""
    try:
        password_hasher.verify(stored_password, provided_password)
        return True
    except argon2.exceptions.VerifyMismatchError:
        return False

def get_current_user(db, user_id):
    """Get current user from database"""
    query = "SELECT id, username, fullname, admin FROM users WHERE id = ?"
    user = db.execute(query, (user_id,)).fetchone()

    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    return {
        'id': user['id'],
        'username': user['username'],
        'fullname': user['fullname'],
        'admin': bool(user['admin'])
    }


# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")

# Serve index.html for '/' and any path starting with '/app'
@app.get("/", response_class=HTMLResponse)
@app.get("/app", response_class=HTMLResponse)
@app.get("/app/{path:path}", response_class=HTMLResponse)
def serve_index(request: Request, path: str = None):
    with db_transaction() as db:
        user = None
        user_id = get_user_id_from_cookie(request)
        if user_id:
            query = "SELECT id, username, fullname, password, admin FROM users WHERE id = ?"
            user = db.execute(query, (user_id,)).fetchone()

        user_flags = {}
        if user:
            user_flags = {
                "id": user['id'],
                "username": user['username'],
                "fullname": user['fullname'],
                "admin": bool(user['admin'])
            }
        user_flags_json = json.dumps(user_flags)
        main_js_src = "/static/main-debug.js" if config.get('debug', False) else "/static/main.js"
        main_css_src ="/static/styles.css" if config.get('debug', False) else "/static/styles.min.css"

        index_html = f"""<!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>{{app_title}}</title>
                    <link rel="icon" type="image/svg" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 16 16'><text x='0' y='14'>{{emoji_icon}}</text></svg>"/>

                    <link rel="preconnect" href="https://fonts.googleapis.com">
                    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
                    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

                    <link rel="stylesheet" href="{main_css_src}">
                    <script src="{main_js_src}"></script>
                </head>
                <body>
                    <h1>{{app_title}}</h1>
                    <script>
                        const safeLocalStorage = {{
                              getItem(key) {{
                                try {{
                                  return localStorage.getItem(key);
                                }} catch(e) {{
                                  return null;
                                }}
                              }},
                              setItem(key, value) {{
                                try {{
                                  localStorage.setItem(key, value);
                                }} catch(e) {{
                                  //
                                }}
                              }},
                              removeItem(key, value) {{
                                try {{
                                  localStorage.removeItem(key, value);
                                }} catch(e) {{
                                  //
                                }}
                              }}
                        }};

                        const user_flags = {user_flags_json};
                        const flags = {{ "flags" : {{ "now": Date.now(), "user": user_flags }} }};
                        var app = Elm.Main.init(flags);


                        app.ports.set_local_storage.subscribe(function (args) {{
                            safeLocalStorage.setItem(args.key, JSON.stringify(args.value));
                        }});

                        app.ports.clear_local_storage.subscribe(function (args) {{
                            safeLocalStorage.removeItem(args);
                        }});


                        app.ports.native_alert.subscribe(function (message) {{
                            alert(message);
                        }});

                        window.addEventListener('storage', function(event) {{
                            console.log('local storage event');
                            console.log(event);
                            if (event.key === 'user') {{
                                app.ports.local_storage_changed.send(
                                    {{ key: event.key,
                                      newValue: JSON.parse(event.newValue) }}
                                );
                            }}
                        }});
                    </script>
                </body>
                </html>"""
        return index_html

# Authentication routes
@app.post('/api/login')
def login(login_data: LoginRequest, response: Response):
    with db_transaction() as db:
        username = login_data.username
        password = login_data.password

        if not username or not password:
            raise HTTPException(status_code=400, detail="Username and password required")

        # Get user from database
        query = "SELECT id, username, email, fullname, password, admin FROM users WHERE username = ?"
        user = db.execute(query, (username,)).fetchone()

        if not user or not verify_password(user['password'], password):
            raise HTTPException(status_code=401, detail="Invalid credentials")

        # Create JWT token with user_id embedded
        payload = {
            'user_id': user['id'],
            'exp': datetime.datetime.now(datetime.UTC) + datetime.timedelta(days=AUTH_COOKIE_MAX_DAYS),
        }
        token = jwt.encode(payload, config["jwtSecret"], algorithm=config["jwtAlgorithm"])

        # Set HTTP-Only secure cookie
        secure_cookie = not config.get('debug', False)  # Don't require HTTPS in debug mode
        response.set_cookie(
            AUTH_COOKIE_NAME,
            token,
            httponly=True,     # Prevents JavaScript access
            secure=secure_cookie,  # Only sent over HTTPS (disabled in debug mode)
            samesite='strict', # Prevents CSRF
            max_age=AUTH_COOKIE_MAX_AGE,
            path='/'           # Available across the entire domain
        )

        return {
            'success': True,
            'message': 'Login successful',
            'user': {
                'id': user['id'],
                'username': user['username'],
                'fullname': user['fullname'],
                'email': user['email'],
                'admin': bool(user['admin'])
            }
        }

@app.post('/api/register')
def register(register_data: RegisterRequest, response: Response):
    with db_transaction() as db:
        username = register_data.username
        password = register_data.password
        email = register_data.email
        fullname = register_data.fullname

        if not username or not password or not email:
            raise HTTPException(status_code=400, detail="Username, password and email required")

        # Check if username already exists
        check_query = "select exists(select 1 from users where username = :username) as user_exists"
        existing_user = db.execute(check_query, {'username': username}).fetchone()

        if existing_user['user_exists']:
            raise HTTPException(status_code=409, detail="Username already exists")

        # Hash the password
        hashed_password = password_hasher.hash(password)

        # Insert new user
        insert_query = """
            insert into users (username, email, fullname, password, admin)
            values (?, ?, ?, ?, ?)
        """
        cursor = db.execute(insert_query, (username, email, fullname, hashed_password, False))
        user_id = cursor.lastrowid

        # Create JWT token for the new user
        payload = {
            'user_id': user_id,
            'exp': datetime.datetime.now(datetime.UTC) + datetime.timedelta(days=AUTH_COOKIE_MAX_DAYS),
        }
        token = jwt.encode(payload, config["jwtSecret"], algorithm=config["jwtAlgorithm"])

        # Set HTTP-Only secure cookie
        secure_cookie = not config.get('debug', False)
        response.set_cookie(
            AUTH_COOKIE_NAME,
            token,
            httponly=True,
            secure=secure_cookie,
            samesite='strict',
            max_age=AUTH_COOKIE_MAX_AGE,
            path='/'
        )

        return {
            'success': True,
            'message': 'Registration successful',
            'user': {
                'id': user_id,
                'username': username,
                'fullname': fullname,
                'email': email,
                'admin': False
            }
        }

@app.post('/api/logout')
def logout(response: Response):
    response.delete_cookie(AUTH_COOKIE_NAME, path='/')
    return {'success': True, 'message': 'Logged out successfully'}

@app.get('/api/me')
def get_me(user_id: int = Depends(get_current_user_id)):
    with db_transaction() as db:
        return get_current_user(db, user_id)

@app.post('/api/profile')
def update_profile(profile_data: ProfileUpdateRequest, user_id: int = Depends(get_current_user_id)):
    with db_transaction() as db:
        fullname = profile_data.fullname

        if fullname is None:
            raise HTTPException(status_code=400, detail="Full name is required")

        # Update user profile
        query = "UPDATE users SET fullname = ? WHERE id = ?"
        db.execute(query, (fullname, user_id))

        # Return updated user data
        return get_current_user(db, user_id)

@app.get('/api/protected-resource')
def protected_resource(user_id: int = Depends(get_current_user_id)):
    return {'message': f'Hello, authenticated user {user_id}!'}


def configure_app(config_dict):
    """Configure JWT and logging after config is loaded."""
    global config
    config = config_dict
    config["jwtAlgorithm"] = "HS256"
    
    # Configure logging based on config
    if config.get('prettyLogging', False):
        import logging
        logging.basicConfig(
            level=logging.DEBUG if config.get('logLevel', 0) <= 0 else logging.INFO,
            format='%(asctime)s [%(levelname)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        logger = logging.getLogger(__name__)
        logger.info(f"Starting application with config: {config['dbFilepath']}")

    # Initialize database schema if using in-memory database, temp file, or if it doesn't exist  
    needs_init = (config['dbFilepath'] == ':memory:' or 
                  not os.path.exists(config['dbFilepath']) or
                  '/tmp/' in config['dbFilepath'])  # Force init for temp files
    
    if needs_init:
        init_test_database()


def init_test_database():
    """Initialize database schema by executing SQL migration files."""
    with db_transaction() as db:
        # Execute the create users table migration
        migration_file = 'sql/migrations/create-users-table.sql'
        with open(migration_file, 'r') as f:
            sql_content = f.read()
        
        # Execute all SQL statements in the file
        db.executescript(sql_content)

if __name__ == '__main__':

    if len(sys.argv) < 2:
        print("Usage: python app.py <config_file.json>")
        sys.exit(1)

    config_file = sys.argv[1]
    try:
        with open(config_file, 'r') as f:
            config_dict = json.load(f)
    except Exception as e:
        print(f"Error loading configuration: {e}")
        sys.exit(1)

    configure_app(config_dict)

    # Run the application with settings from config
    uvicorn.run(
        app,
        host='localhost',
        port=config.get('port', 8080),
        log_level="debug" if config.get('debug', False) else "info"
    )
